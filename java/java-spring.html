<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>VitePress | VitePress</title>
    <meta name="description" content="A VitePress site">
    <link rel="preload stylesheet" href="/assets/style.1bd93765.css" as="style">
    <script type="module" src="/assets/app.f517ab68.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.2ed14f66.woff2" as="font" type="font/woff2" crossorigin="">
  <link rel="modulepreload" href="/assets/chunks/framework.afd645d4.js">
  <link rel="modulepreload" href="/assets/chunks/theme.7479516f.js">
  <link rel="modulepreload" href="/assets/java_java-spring.md.c2c79922.lean.js">
  <script id="check-dark-light">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-b2cf3e0b><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8616af1></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8616af1> Skip to content </a><!--]--><!----><header class="VPNav" data-v-b2cf3e0b data-v-7e5bc4a5><div class="VPNavBar" data-v-7e5bc4a5 data-v-1d30fa41><div class="container" data-v-1d30fa41><div class="title" data-v-1d30fa41><div class="VPNavBarTitle" data-v-1d30fa41 data-v-f4ef19a3><a class="title" href="/" data-v-f4ef19a3><!--[--><!--]--><!--[--><img class="VPImage logo" src="/edit.png" alt data-v-6db2186b><!--]--><!--[-->Junlogz-Docs<!--]--><!--[--><!--]--></a></div></div><div class="content" data-v-1d30fa41><div class="curtain" data-v-1d30fa41></div><div class="content-body" data-v-1d30fa41><!--[--><!--]--><!----><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-1d30fa41 data-v-7f418b0f><span id="main-nav-aria-label" class="visually-hidden" data-v-7f418b0f>Main Navigation</span><!--[--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-764effdf><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-764effdf><span class="text" data-v-764effdf><!----> Java <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-764effdf><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-764effdf><div class="VPMenu" data-v-764effdf data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-d2c93bab><a class="VPLink link" href="/java/java-base.html" data-v-d2c93bab data-v-8f4dc553><!--[-->Java基础<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-d2c93bab><a class="VPLink link" href="/java/java-jvm.html" data-v-d2c93bab data-v-8f4dc553><!--[-->Jvm<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-d2c93bab><a class="VPLink link" href="/java/java-spring.html" data-v-d2c93bab data-v-8f4dc553><!--[-->Spring<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-d2c93bab><a class="VPLink link" href="/java/java-mybatis.html" data-v-d2c93bab data-v-8f4dc553><!--[-->Mybatis<!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-764effdf><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-764effdf><span class="text" data-v-764effdf><!----> 设计模式 <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-764effdf><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-764effdf><div class="VPMenu" data-v-764effdf data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuGroup" data-v-e7ea1737 data-v-69e747b5><!----><!--[--><!--[--><div class="VPMenuLink" data-v-69e747b5 data-v-d2c93bab><a class="VPLink link" href="/pattern/creational-pattern.html" data-v-d2c93bab data-v-8f4dc553><!--[-->创建型模式<!--]--><!----></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-e7ea1737 data-v-69e747b5><!----><!--[--><!--[--><div class="VPMenuLink" data-v-69e747b5 data-v-d2c93bab><a class="VPLink link" href="/pattern/creational-pattern.html" data-v-d2c93bab data-v-8f4dc553><!--[-->结构型模式<!--]--><!----></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-e7ea1737 data-v-69e747b5><!----><!--[--><!--[--><div class="VPMenuLink" data-v-69e747b5 data-v-d2c93bab><a class="VPLink link" href="/pattern/creational-pattern.html" data-v-d2c93bab data-v-8f4dc553><!--[-->行为模式<!--]--><!----></a></div><!--]--><!--]--></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-764effdf><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-764effdf><span class="text" data-v-764effdf><!----> 中间件 <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-764effdf><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-764effdf><div class="VPMenu" data-v-764effdf data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-d2c93bab><a class="VPLink link" href="/middleware/redis.html" data-v-d2c93bab data-v-8f4dc553><!--[-->redis<!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/sql/mysql.html" tabindex="0" data-v-7f418b0f data-v-37adc828 data-v-8f4dc553><!--[-->数据库<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="https://github.com/Junlogz" target="_blank" rel="noreferrer" tabindex="0" data-v-7f418b0f data-v-37adc828 data-v-8f4dc553><!--[-->github<!--]--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" height="24px" viewbox="0 0 24 24" width="24px" class="icon" data-v-8f4dc553><path d="M0 0h24v24H0V0z" fill="none"></path><path d="M9 5v2h6.59L4 18.59 5.41 20 17 8.41V15h2V5H9z"></path></svg></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-1d30fa41 data-v-f6a63727><label title="toggle dark mode" data-v-f6a63727 data-v-a9c8afb8><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-checked="false" data-v-a9c8afb8 data-v-f3c41672><span class="check" data-v-f3c41672><span class="icon" data-v-f3c41672><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-a9c8afb8><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-a9c8afb8><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></label></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-1d30fa41 data-v-0394ad82 data-v-f6988cfb><!--[--><a class="VPSocialLink" href="https://github.com/Junlogz" aria-label="github" target="_blank" rel="noopener" data-v-f6988cfb data-v-c530cc0a><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-1d30fa41 data-v-40855f84 data-v-764effdf><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-764effdf><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-764effdf><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-764effdf><div class="VPMenu" data-v-764effdf data-v-e7ea1737><!----><!--[--><!--[--><!----><div class="group" data-v-40855f84><div class="item appearance" data-v-40855f84><p class="label" data-v-40855f84>Appearance</p><div class="appearance-action" data-v-40855f84><label title="toggle dark mode" data-v-40855f84 data-v-a9c8afb8><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-checked="false" data-v-a9c8afb8 data-v-f3c41672><span class="check" data-v-f3c41672><span class="icon" data-v-f3c41672><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-a9c8afb8><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-a9c8afb8><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></label></div></div></div><div class="group" data-v-40855f84><div class="item social-links" data-v-40855f84><div class="VPSocialLinks social-links-list" data-v-40855f84 data-v-f6988cfb><!--[--><a class="VPSocialLink" href="https://github.com/Junlogz" aria-label="github" target="_blank" rel="noopener" data-v-f6988cfb data-v-c530cc0a><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-1d30fa41 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><!----></header><!----><!----><div class="VPContent" id="VPContent" data-v-b2cf3e0b data-v-a494bd1d><div class="VPDoc has-aside" data-v-a494bd1d data-v-c4b0d3cf><!--[--><!--]--><div class="container" data-v-c4b0d3cf><div class="aside" data-v-c4b0d3cf><div class="aside-curtain" data-v-c4b0d3cf></div><div class="aside-container" data-v-c4b0d3cf><div class="aside-content" data-v-c4b0d3cf><div class="VPDocAside" data-v-c4b0d3cf data-v-3f215769><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" data-v-3f215769 data-v-ff0f39c8><div class="content" data-v-ff0f39c8><div class="outline-marker" data-v-ff0f39c8></div><div class="outline-title" data-v-ff0f39c8>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-ff0f39c8><span class="visually-hidden" id="doc-outline-aria-label" data-v-ff0f39c8> Table of Contents for current page </span><ul class="root" data-v-ff0f39c8 data-v-8f12e865><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-c4b0d3cf><div class="content-container" data-v-c4b0d3cf><!--[--><!--]--><!----><main class="main" data-v-c4b0d3cf><div style="position:relative;" class="vp-doc _java_java-spring" data-v-c4b0d3cf><div><h2 id="_1-spring的重要模块" tabindex="-1">1. Spring的重要模块 <a class="header-anchor" href="#_1-spring的重要模块" aria-label="Permalink to &quot;1. Spring的重要模块&quot;">​</a></h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44bcf12479f94a0e8d509ae44f5fb696~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p><strong>Spring Core</strong></p><p>核心模块， Spring 其他所有的功能基本都需要依赖于该模块，主要提供 IoC 依赖注入功能的支持。</p><p><strong>Spring Aspects</strong></p><p>该模块为与 AspectJ 的集成提供支持。</p><p><strong>Spring AOP</strong></p><p>提供了面向切面的编程实现。</p><p><strong>Spring Data Access/Integration ：</strong></p><p>Spring Data Access/Integration 由 5 个模块组成：</p><ul><li>spring-jdbc : 提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li><li>spring-tx : 提供对事务的支持。</li><li>spring-orm : 提供对 Hibernate 等 ORM 框架的支持。</li><li>spring-oxm ： 提供对 Castor 等 OXM 框架的支持。</li><li>spring-jms : Java 消息服务。</li></ul><p><strong>Spring Web</strong></p><p>Spring Web 由 4 个模块组成：</p><ul><li>spring-web ：对 Web 功能的实现提供一些最基础的支持。</li><li>spring-webmvc ： 提供对 Spring MVC 的实现。</li><li>spring-websocket ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li><li>spring-webflux ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步.</li></ul><p><strong>Spring Test</strong></p><p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p><p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。</p><h2 id="_2-spring-ioc-aop" tabindex="-1">2. Spring IOC &amp; AOP <a class="header-anchor" href="#_2-spring-ioc-aop" aria-label="Permalink to &quot;2. Spring IOC &amp; AOP&quot;">​</a></h2><h3 id="谈谈自己对于-spring-ioc-的了解" tabindex="-1">谈谈自己对于 Spring IoC 的了解 <a class="header-anchor" href="#谈谈自己对于-spring-ioc-的了解" aria-label="Permalink to &quot;谈谈自己对于 Spring IoC 的了解&quot;">​</a></h3><p><strong>IoC（Inverse of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p><p><strong>为什么叫控制反转？</strong></p><ul><li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li><li><strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/246f38ca8c27489290976f0fada7bd7e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p><p>在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p><p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p><p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p><h3 id="谈谈自己对于-aop-的了解" tabindex="-1">谈谈自己对于 AOP 的了解 <a class="header-anchor" href="#谈谈自己对于-aop-的了解" aria-label="Permalink to &quot;谈谈自己对于 AOP 的了解&quot;">​</a></h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9001cab86e4c43fd8bb56923e051fe16~tplv-k3u1fbpfcp-zoom-1.image" alt="SpringAOPProcess"></p><p>当然你也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p><h3 id="spring-aop-和-aspectj-aop-有什么区别" tabindex="-1">Spring AOP 和 AspectJ AOP 有什么区别？ <a class="header-anchor" href="#spring-aop-和-aspectj-aop-有什么区别" aria-label="Permalink to &quot;Spring AOP 和 AspectJ AOP 有什么区别？&quot;">​</a></h3><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多</p><h2 id="_3-spring-bean" tabindex="-1">3. Spring Bean <a class="header-anchor" href="#_3-spring-bean" aria-label="Permalink to &quot;3. Spring Bean&quot;">​</a></h2><h3 id="什么是-spring-bean" tabindex="-1">什么是 Spring Bean？ <a class="header-anchor" href="#什么是-spring-bean" aria-label="Permalink to &quot;什么是 Spring Bean？&quot;">​</a></h3><p>简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。</p><p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p><h3 id="将一个类声明为-bean-的注解有哪些" tabindex="-1">将一个类声明为 Bean 的注解有哪些? <a class="header-anchor" href="#将一个类声明为-bean-的注解有哪些" aria-label="Permalink to &quot;将一个类声明为 Bean 的注解有哪些?&quot;">​</a></h3><ul><li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li><li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><h3 id="component-和-bean-的区别是什么" tabindex="-1">Component 和 @Bean 的区别是什么？ <a class="header-anchor" href="#component-和-bean-的区别是什么" aria-label="Permalink to &quot;Component 和 @Bean 的区别是什么？&quot;">​</a></h3><ul><li><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li><li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li><li><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li></ul><p><code>@Bean</code>注解使用示例：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Configuration</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">class</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">AppConfig</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Bean</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">TransferService</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">transferService</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">TransferServiceImpl</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>上面的代码相当于下面的 xml 配置</p><div class="language-xml"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">beans</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">bean</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">id</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">transferService</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">class</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">com.acme.TransferServiceImpl</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">/&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">beans</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><h3 id="注入-bean-的注解有哪些" tabindex="-1">注入 Bean 的注解有哪些？ <a class="header-anchor" href="#注入-bean-的注解有哪些" aria-label="Permalink to &quot;注入 Bean 的注解有哪些？&quot;">​</a></h3><p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p><table><thead><tr><th>Annotaion</th><th>Package</th><th>Source</th></tr></thead><tbody><tr><td><code>@Autowired</code></td><td><code>org.springframework.bean.factory</code></td><td>Spring 2.5+</td></tr><tr><td><code>@Resource</code></td><td><code>javax.annotation</code></td><td>Java JSR-250</td></tr><tr><td><code>@Inject</code></td><td><code>javax.inject</code></td><td>Java JSR-330</td></tr></tbody></table><p><code>@Autowire </code>@Resource<code>使用的比较多一些。</code></p><h3 id="autowired和-resource的区别" tabindex="-1">@Autowired和@Resource的区别 <a class="header-anchor" href="#autowired和-resource的区别" aria-label="Permalink to &quot;@Autowired和@Resource的区别&quot;">​</a></h3><blockquote><p>共同点</p></blockquote><p>@Resource和@Autowired都可以作为注入属性的修饰，在接口仅有单一实现类时，两个注解的修饰效果相同，可以互相替换，不影响使用。</p><blockquote><h3 id="autowired-vs-resource" tabindex="-1">@Autowired VS @Resource <a class="header-anchor" href="#autowired-vs-resource" aria-label="Permalink to &quot;@Autowired VS @Resource&quot;">​</a></h3><p>事实上，他们的基本功能都是通过注解实现<strong>依赖注入</strong>，只不过<code>@Autowired</code>是<code>Spring</code>定义的，而<code>@Resource</code>是<code>JSR-250</code>定义的。大致功能基本相同，但是还有一些细节不同：</p></blockquote><ul><li><strong>依赖识别方式</strong>：@Autowired默认是<strong>byType</strong>可以使用@Qualifier指定Name，@Resource<strong>默认ByName</strong>如果<strong>找不到则ByType</strong></li><li><strong>适用对象</strong>：@Autowired可以对<strong>构造器、方法、参数、字段</strong>使用，@Resource只能对<strong>方法、字段</strong>使用</li><li><strong>提供方</strong>：@Autowired是<strong>Spring</strong>提供的，@Resource是<strong>JSR-250</strong>提供的（J2EE提供）</li></ul><h2 id="_4-spring-框架中用到哪些设计模式" tabindex="-1">4. Spring 框架中用到哪些设计模式 <a class="header-anchor" href="#_4-spring-框架中用到哪些设计模式" aria-label="Permalink to &quot;4. Spring 框架中用到哪些设计模式&quot;">​</a></h2><ul><li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li></ul><h2 id="_5-spring事务" tabindex="-1">5. Spring事务 <a class="header-anchor" href="#_5-spring事务" aria-label="Permalink to &quot;5. Spring事务&quot;">​</a></h2><h3 id="_5-1-spring-管理事务的方式有几种" tabindex="-1">5.1 Spring 管理事务的方式有几种？ <a class="header-anchor" href="#_5-1-spring-管理事务的方式有几种" aria-label="Permalink to &quot;5.1 Spring 管理事务的方式有几种？&quot;">​</a></h3><ul><li><strong>编程式事务</strong> ： 在代码中硬编码(不推荐使用) : 通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</li><li><strong>声明式事务</strong> ： 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）</li></ul><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>。</p><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p><p>正确的事务传播行为可能的值如下:</p><p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p><p>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p><p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p><p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p><p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong></p><p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</p><p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p><p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p><h3 id="_5-2-spring-事务中的隔离级别有哪几种" tabindex="-1">5.2 Spring 事务中的隔离级别有哪几种? <a class="header-anchor" href="#_5-2-spring-事务中的隔离级别有哪几种" aria-label="Permalink to &quot;5.2 Spring 事务中的隔离级别有哪几种?&quot;">​</a></h3><ul><li><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> :使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别.</li><li><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li><li><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong> : 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li><li><strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code></strong> : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li><li><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong> : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h3 id="_5-3-transactional-rollbackfor-exception-class-注解了解吗" tabindex="-1">5.3 @Transactional(rollbackFor = Exception.class)注解了解吗？ <a class="header-anchor" href="#_5-3-transactional-rollbackfor-exception-class-注解了解吗" aria-label="Permalink to &quot;5.3  @Transactional(rollbackFor = Exception.class)注解了解吗？&quot;">​</a></h3><p><code>Exception</code> 分为运行时异常 <code>RuntimeException</code> 和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p><p>当 <code>@Transactional</code> 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p><p>在 <code>@Transactional</code> 注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚，加上 <code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</p><p><code>@Transactional</code> 注解一般可以作用在<code>类</code>或者<code>方法</code>上。</p><ul><li><strong>作用于类</strong>：当把<code>@Transactional</code> 注解放在类上时，表示所有该类的 public 方法都配置相同的事务属性信息。</li><li><strong>作用于方法</strong>：当类配置了<code>@Transactional</code>，方法也配置了<code>@Transactional</code>，方法的事务会覆盖类的事务配置信息。</li></ul><h2 id="_6-spring3种di方法" tabindex="-1">6. Spring3种DI方法 <a class="header-anchor" href="#_6-spring3种di方法" aria-label="Permalink to &quot;6. Spring3种DI方法&quot;">​</a></h2><blockquote><p>Field属性注入</p></blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Service</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">class</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">BService</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Autowired</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#C792EA;">AService</span><span style="color:#BABED8;"> aService</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><blockquote><p>set 方法注入</p></blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Service</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">class</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">BService</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#C792EA;">AService</span><span style="color:#BABED8;"> aService</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Autowired</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">void</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">setaService</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">AService</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">aService</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#BABED8;">aService </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> aService</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><blockquote><p>构造方法注入</p></blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Service</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">class</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">AService</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#C792EA;">BService</span><span style="color:#BABED8;"> bService</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Autowired</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">AService</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">BService</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">bService</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#BABED8;">bService </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> bService</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>参考Spring官方文档，建议了如下的使用场景：</p><ul><li><strong>构造器注入</strong>：<strong>强依赖性</strong>（即必须使用此依赖），<strong>不变性</strong>（各依赖不会经常变动）</li><li><strong>Setter注入</strong>：<strong>可选</strong>（没有此依赖也可以工作），<strong>可变</strong>（依赖会经常变动）</li><li><strong>Field注入</strong>：大多数情况下尽量<strong>少使用</strong>字段注入，一定要使用的话， <strong>@Resource相对@Autowired</strong>对IoC容器的<strong>耦合更低</strong></li></ul><h3 id="field注入的缺点" tabindex="-1">Field注入的缺点 <a class="header-anchor" href="#field注入的缺点" aria-label="Permalink to &quot;Field注入的缺点&quot;">​</a></h3><ul><li><p><strong>不能像构造器那样注入不可变的对象</strong></p></li><li><p><strong>依赖对外部不可见</strong>，外界可以看到构造器和setter，但无法看到私有字段，自然无法了解所需依赖</p></li><li><p>会导致<strong>组件与IoC容器紧耦合</strong>（这是最重要的原因，离开了IoC容器去使用组件，在注入依赖时就会十分困难）</p></li><li><p>导致<strong>单元测试也必须使用IoC容器</strong>，原因同上</p></li></ul><p>Field注入虽然有很多缺点，但它的好处也不可忽略：那就是<strong>太方便了</strong>。使用构造器或者setter注入需要写更多业务无关的代码，十分麻烦，而字段注入大幅简化了它们。并且绝大多数情况下业务代码和框架就是强绑定的，完全松耦合只是一件理想上的事，牺牲了敏捷度去过度追求松耦合反而得不偿失。</p><p>idea的警告</p><blockquote><p>Field injection is not recommended (字段注入是不被推荐的)</p></blockquote><p><strong>@Autowired</strong>是<strong>Spring</strong>提供的，它是<strong>特定IoC提供的特定注解</strong>，这就导致了应用与框架的<strong>强绑定</strong>，一旦换用了其他的IoC框架，是<strong>不能够支持注入</strong>的。而 <strong>@Resource</strong>是<strong>JSR-250</strong>提供的，它是<strong>Java标准</strong>，我们使用的IoC容器应当去兼容它，这样即使更换容器，也可以正常工作。</p><h2 id="_7-spring常用注解" tabindex="-1">7. Spring常用注解 <a class="header-anchor" href="#_7-spring常用注解" aria-label="Permalink to &quot;7. Spring常用注解&quot;">​</a></h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04745ab1d9654c5b82ec582dc5ccfb04~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><blockquote><p>Spring1.2</p></blockquote><ul><li>@Transcational：事务</li></ul><blockquote><p>spring2.0</p></blockquote><ul><li><p>@Required：<strong>@Required</strong> 注释应用于 bean 属性的 setter 方法，<strong>是用于检查一个Bean的属性在配置期间是否被赋值。</strong></p></li><li><p>@Repository：用在持久层的接口上，这个注解是将接口的一个实现类交给spring管理。</p><p>为什么有时候我们不用@Repository来注解接口,我们照样可以注入到这个接口的实现类呢? 1、spring配置文件中配置了MapperScannerConfigurer这个bean，它会扫描持久层接口创建实现类并交给spring管理。</p><p>2、接口上使用了@Mapper注解或者springboot中主类上使用了@MapperScan注解，和MapperScannerConfigurer作用一样。</p><p>注：不使用@Repository注解，idea会报警告，提示找不到这个bean，直接忽略即可。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efa8f774e24e41ce9531629bb72457d1~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p></li></ul><blockquote><p>spring2.5</p></blockquote><ul><li><p>@Controller</p></li><li><p>@Service</p></li><li><p>@Component</p></li><li><p>@RequestMapping</p></li><li><p>@Autowired：依赖注入</p></li><li><p>@Qualifier：在@Autowired中，@Qualifier用来指定Name；两个类都实现了同一个接口进行标识</p></li></ul><p>Spring如何通过注解注入？ 不过大家仔细想一下，为什么打上注解了就能实现接口功能了呢？换句话说，Spring怎么样找到开发者自定义的Controller把对应的请求分发到对应的方法上呢？</p><p>首先，要在Spring配置文件的头文件中引入spring-context。</p><p>其次，使用<a href="context:component-scan" target="_blank" rel="noreferrer">context:component-scan</a>元素启动“包扫描”功能。</p><p>例如&lt;context:component-scan base-package=&quot;com.xxx.controller&quot;/&gt;</p><p>base-package是值是包的路径。意思就是，启动了报扫描功能，将com.myz.controller这个包下以及子包下的所有类扫描一遍，将标记有@Controller、@Service、@repository、@Component等注解的类注入到IOC容器中，作为Spring的Bean来管理。</p><p>这样，Spring就能找到Controller类，通过@RequestMapping注解处理对应的请求。</p><blockquote><p>Spring3</p></blockquote><ul><li><p>@Configuration用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。</p></li><li><p>@ImportResource用于导入Spring的配置文件，让配置文件（如applicationContext.xml）里面的内容生效；</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">SpringBootApplication</span></span>
<span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">EnableSwagger2</span></span>
<span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">ImportResource</span><span style="color:#89DDFF;">({</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">classpath*:applicationContext.xml</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">})</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">class</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">ProductApplication</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;"> </span></span>
<span class="line"><span style="color:#BABED8;">   </span><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">static</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">void</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">[]</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">      SpringApplication</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">run</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;">ProductApplication</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">class</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> args</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#BABED8;">   </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div></li><li><p>@ComponentScan 注解的作用就是根据指定的扫描路径，把路径中符合扫描规则的类装配到 Spring 容器中。</p><ul><li><code>@ComponentScan</code>注解与XML文件中的<code>context:component-scan</code>标签等效。</li></ul></li><li><p><code>@Import</code>注解提供了<code>@Bean</code>注解的功能，同时还有原来<code>Spring</code>基于 xml 配置文件里的<code>&lt;import&gt;</code>标签组织多个分散的xml文件的功能，当然在这里是组织多个分散的<code>@Configuration</code>的类。</p></li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fdde9d3fce2484c9cff760f1ecdde1d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>例如在这个JavaConfig中再引入其他RedisConfig或者MybatisConfig；与原来<code>Spring</code>基于 xml 配置文件里的<code>&lt;import&gt;</code>功能一样</p><p><code>第二种</code>是实现ImportSelector接口，那么就会把该接口重写的方法返回的内容注入到容器中去</p><p><code>第三种</code>是实现ImportBeanDefinitionRegistrar，提供一个注册器，自己在注册器注册</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac4a9164534d4ea5b7e7dec3e8c0059f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>在SpringBoot的自动装配中非常重要，也是EnableXXX的前置基础。</p><blockquote><p>Spring4</p></blockquote><ul><li><p>@Conditional：条件注解，决定是否将该对象注入到容器中去</p><ul><li>实现Condition接口，重写matches方法</li></ul></li><li><p>@CrossOrigin：跨域注解</p></li></ul><blockquote><p>Spring5.0</p></blockquote><ul><li>@Indexed：加速@ComponentScan的包扫描，<code>减少了IO次数，只用读取一次文件</code>，<code>文件会把有被相关注解修饰的类都记录</code>，然后通过反射将这些Java类注入到容器中去</li></ul><h2 id="_8-sringboot的重要前提spi" tabindex="-1">8. SringBoot的重要前提SPI <a class="header-anchor" href="#_8-sringboot的重要前提spi" aria-label="Permalink to &quot;8. SringBoot的重要前提SPI&quot;">​</a></h2><p>SPI，全程 Service Provider interface, 是一种服务发现机制，它通过在ClassPath路径下的META-INF/service文件夹查找文件，自动加载文件里所定义的类，这易机制为很多框架扩展提供了可能，比如在Dubbo，JDBC中都使用到了SPI机制</p><blockquote><p>这个文件夹就相当于一个约定，需要使用某个提供好标准服务接口，都会扫描这个文件下的路径，然后具体实现</p><p>比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是 <strong>解耦</strong>。</p></blockquote><p>当服务的提供者提供了一种接口的实现之后，需要在classpath下的<code>META-INF/services/</code>目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的<code>META-INF/services/</code>中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：<code>java.util.ServiceLoader</code>。</p><blockquote><p>实例</p></blockquote><p>我们现在需要使用一个内容搜索接口，搜索的实现可能是基于文件系统的搜索，也可能是基于数据库的搜索。</p><ul><li>先定义好接口</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">interface</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Search</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">List</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">searchDoc</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">keyword</span><span style="color:#89DDFF;">);</span><span style="color:#BABED8;">   </span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#BABED8;">  </span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">pdai</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#BABED8;"> 代码已经复制到剪贴板</span></span></code></pre></div><ul><li>文件搜索实现</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">class</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">FileSearch</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">implements</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Search</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Override</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">List</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">searchDoc</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">keyword</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">文件搜索 </span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">+</span><span style="color:#BABED8;">keyword</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#BABED8;">  </span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">pdai</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#BABED8;"> 代码已经复制到剪贴板</span></span></code></pre></div><ul><li>数据库搜索实现</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">class</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">DatabaseSearch</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">implements</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Search</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Override</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">List</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">searchDoc</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">keyword</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">数据搜索 </span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">+</span><span style="color:#BABED8;">keyword</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#BABED8;">  </span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">pdai</span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#BABED8;"> 代码已经复制到剪贴板</span></span></code></pre></div><ul><li>resources 接下来可以在resources下新建META-INF/services/目录，然后新建接口全限定名的文件：<code>com.cainiao.ys.spi.learn.Search</code>，里面加上我们需要用到的实现类</li></ul><div class="language-xml"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">com.cainiao.ys.spi.learn.FileSearch</span></span></code></pre></div><ul><li>测试方法</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">class</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">TestCase</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">static</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">void</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">[]</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#C792EA;">ServiceLoader</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Search</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;"> s </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> ServiceLoader</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">load</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;">Search</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">class</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#C792EA;">Iterator</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Search</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;"> iterator </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> s</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">iterator</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;">iterator</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">hasNext</span><span style="color:#89DDFF;">())</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">           </span><span style="color:#C792EA;">Search</span><span style="color:#BABED8;"> search </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;">  iterator</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">next</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#BABED8;">           search</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">searchDoc</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">hello world</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>可以看到输出结果：文件搜索 hello world</p><p>如果在<code>com.cainiao.ys.spi.learn.Search</code>文件里写上两个实现类，那最后的输出结果就是两行了。</p><p>这就是因为<code>ServiceLoader.load(Search.class)</code>在加载某接口时，会去<code>META-INF/services</code>下找接口的全限定名文件，再根据里面的内容加载相应的实现类。</p><p>这就是spi的思想，接口的实现由provider实现，provider只用在提交的jar包里的<code>META-INF/services</code>下根据平台定义的接口新建文件，并添加进相应的实现类内容就好。</p><p>著作权归<a href="https://pdai.xn--tech-8e6h48v." target="_blank" rel="noreferrer">https://pdai.tech所有.</a> 链接：<a href="https://pdai.tech/md/java/advanced/java-advanced-spi.html" target="_blank" rel="noreferrer">https://pdai.tech/md/java/advanced/java-advanced-spi.html</a></p><h3 id="spi机制的缺陷" tabindex="-1">SPI机制的缺陷 <a class="header-anchor" href="#spi机制的缺陷" aria-label="Permalink to &quot;SPI机制的缺陷&quot;">​</a></h3><p>通过上面的解析，可以发现，我们使用SPI机制的缺陷：</p><ul><li>不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。</li><li>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。</li><li>多个并发多线程使用 ServiceLoader 类的实例是不安全的。</li></ul><h2 id="_9-spring-中的-bean-的作用域有哪些" tabindex="-1">9. Spring 中的 bean 的作用域有哪些? <a class="header-anchor" href="#_9-spring-中的-bean-的作用域有哪些" aria-label="Permalink to &quot;9. Spring 中的 bean 的作用域有哪些?&quot;">​</a></h2><p><code>singleton</code> : 唯一 bean 实例，在Spring的IoC容器中只存在一个对象实例，所有该对象的引用都共享这个实例</p><p><code>prototype</code> : 每次请求都会创建一个新的 bean 实例。</p><p><code>request</code> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</p><p><code>session</code> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内</p><p>有效。</p><h2 id="_10-普通java对象和spring所管理的bean实例的过程是有区别的" tabindex="-1">10 普通Java对象和Spring所管理的Bean实例的过程是有区别的 <a class="header-anchor" href="#_10-普通java对象和spring所管理的bean实例的过程是有区别的" aria-label="Permalink to &quot;10 普通Java对象和Spring所管理的Bean实例的过程是有区别的&quot;">​</a></h2><ol><li>Java源码被编译为class文件</li><li>等到类需要被初始化时(比如new 反射等)</li><li>class文件被虚拟机通过类加载器加载到JVM</li><li>初始化对象供我们使用</li></ol><blockquote><p>简单来说,可以理解为它是用Class对象做为模板进而创建出具体的实例</p></blockquote><p>而spring所管理的bean不同的是,除了Class对象之外,还会使用beanDefinition实例来描述对象的信息</p><p>比如可以在spring所管理的Bean有一系列的描述 : @Scope, @Lazy, @DependsOn</p><p><a href="https://www.cnblogs.com/tanghaorong/p/14165477.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/tanghaorong/p/14165477.html</a></p><ul><li>@Scope <ul><li>可以用在类上和方法上，用来配置bean的作用域，等效于bean xml中的bean元素中的scope属性</li></ul></li><li>@Lazy <ul><li>Spring IoC（ApplicationContext）容器一般都会在启动的时候实例化所有单实例 Bean。但是如果我们想要 Spring 在启动的时候延迟加载 Bean，即在调用某个 Bean 的时候再去初始化</li><li>@Lazy等效于bean.xml中bean元素的lazy-init属性</li></ul></li><li>@DenpendsOn <ul><li>用于指定某个类的创建依赖的bean对象先创建。简单来说就是这个组件要依赖于另一个组件，也就是说被依赖的组件会比该组件先注册到IOC容器中。</li><li>可以用在任意类型和方法上，等效于bean xml中的bean元素中的depend-on属性。</li></ul></li></ul><blockquote><p>可以理解为Class只描述了类的信息, 而BeanDefinition描述了对象的信息</p></blockquote><h2 id="_11-bean的生命周期" tabindex="-1">11 Bean的生命周期 <a class="header-anchor" href="#_11-bean的生命周期" aria-label="Permalink to &quot;11 Bean的生命周期&quot;">​</a></h2><p><a href="https://juejin.cn/post/6979398918429736996#comment" target="_blank" rel="noreferrer">https://juejin.cn/post/6979398918429736996#comment</a></p><p>对于普通的 Java 对象来说，它们的生命周期就是：</p><ul><li>实例化</li><li>该对象不再被使用时通过垃圾回收机制进行回收</li></ul><p>而对于 Spring Bean 的生命周期来说：</p><ul><li>实例化 Instantiation</li><li>属性注入 Populate</li><li>初始化 Initialization</li><li>使用 bean</li><li>销毁 Destruction</li></ul><blockquote><p>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 使用 -&gt; 销毁</p></blockquote><ul><li><p>创建阶段主要是创建对象，这里我们看到，对象的创建权交由Spring管理了，不再是我们手动new了，这也是IOC的概念。</p></li><li><p>属性填充阶段主要是进行依赖的注入，将当前对象依赖的bean对象，从Spring容器中找出来，然后填充到对应的属性中去。</p></li><li><p>初始化bean阶段做的事情相对比较复杂，包括回调各种Aware接口、回调各种初始化方法、生成AOP代理对象也在该阶段进行，该阶段主要是完成初始化回调，后面我们慢慢分析。</p></li><li><p>使用bean阶段，主要是bean创建完成，在程序运行期间，提供服务的阶段。</p></li><li><p>销毁bean阶段，主要是容器关闭或停止服务，对bean进行销毁处理。</p></li></ul><blockquote><p>大概流程</p></blockquote><ol><li><p>spring在启动时会扫描xml/注解/JavaConfig中需要被spring管理的bean信息</p></li><li><p>接着将这些信息封装成BeanDefinition，最后会把这些信息放在一个beanDefinitionMap中</p><ul><li>这个Map的key就是beanName, value则是BeanDefinition对象</li></ul></li><li><p>到这里其实就是把定义的元数据加载起来, 目前真实对象还没实例化</p></li><li><p>接着会遍历这里beanDefinitionMap,执行BeanFactoryPostProcessor这个Bean工厂后置处理器的逻辑, 比如平时定义的占位符信息, 就是通过BeanFactoryPostProcessor的子类注入进去的,也可以用自定义的,不过运用的比较少</p></li></ol><h3 id="实例化" tabindex="-1">实例化 <a class="header-anchor" href="#实例化" aria-label="Permalink to &quot;实例化&quot;">​</a></h3><p>在Spring里面是通过反射来实现的, 一般情况下会通过反射选择合适的构造器来把对象实例化,</p><p>但这里把对象实例化, 只是把对象给创建出来, 而对象具体的属性是还没注入的.</p><ul><li>比如我的对象是UserService, UserService对象依赖着RoleService对象, 这时候RoleService还是null的</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0db09afcacb0457d9ded8243f16dcf9c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1960950d22104a639e09de10d2bff105~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="01创建bean.png"></p><h3 id="接下来就是把对象相关属性给注入-属性赋值" tabindex="-1">接下来就是把对象相关属性给注入 - 属性赋值 <a class="header-anchor" href="#接下来就是把对象相关属性给注入-属性赋值" aria-label="Permalink to &quot;接下来就是把对象相关属性给注入 - 属性赋值&quot;">​</a></h3><p>本阶段完成了Spring的核心功能之一：依赖注入，包括<code>自动注入</code>、<code>@Autowired注入</code>、<code>@Resource注入</code>等。Spring会根据bean的注入模型(<code>默认不自动注入</code>)，选择根据名称自动注入还是根据类型自动注入。然后调用<code>InstantiationAwareBeanPostProcessor#postProcessProperties()</code>完成@Autowired和@Resource的属性注入。</p><h3 id="初始化" tabindex="-1">初始化 <a class="header-anchor" href="#初始化" aria-label="Permalink to &quot;初始化&quot;">​</a></h3><ol><li>首先判断该Bean是否实现了Aware相关接口, 如果存在则填充相关资源,</li></ol><ul><li>比如项目中需要通过代码程序的方式去获取指定的spring Bean, 会抽取一个工具类去实现ApplicationContextAware接口, 来获取ApplicationContext对象, 进而获取Spring bean;</li></ul><ol start="2"><li>处理完Aware相关的接口后, 就会到BeanPostProcessor后置处理器, 后主处理器有两个方法, 一个是before, 一个是after.</li></ol><ul><li>这个BeanPostProcessor后置处理器是AOP实现的关键, 关键子类AnnotationAwareAspectAutoProxyCreator</li></ul><ol start="3"><li>BeanPostProcessor相关子类的before方法执行完后, 就执行init相关方法</li></ol><ul><li>比如@PostConstruct, 实现了Initializing Bean接口, 定义的init- method方法, 顺序也是这3个顺序</li><li>这些是spring给我们的<code>拓展</code></li></ul><ol start="4"><li>基本重要的流程已经走完了, 我们就可以获取到对象去使用了</li><li>销毁的时候就看有没有配置相关的destory方法, 执行就完事了</li></ol><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ff15be01a614cf08aa6e105ff157558~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="_12-spring解决循环依赖" tabindex="-1">12. Spring解决循环依赖 <a class="header-anchor" href="#_12-spring解决循环依赖" aria-label="Permalink to &quot;12. Spring解决循环依赖&quot;">​</a></h2><p>从上面我们知道, 对象属性注入, 在对象实例化之后的</p><blockquote><p>大致过程</p></blockquote><ol><li>首先A对象实例化, 然后对属性进行注入, 发现依赖B对象</li><li>B对象此时还没创建出来, 所以转头去实例化B对象</li><li>B对象实例化后, 发现需要依赖A对象, A对象已经实例化了, 所以B对象最终能够完成创建</li><li>B对象返回到A对象的属性注入的方法上, A对象最终也完成创建</li><li>大概的过程就是这样</li></ol><blockquote><p>原理</p></blockquote><p>原理是运用了三级缓存</p><p>这里的三级换成其实就是三个Map</p><ul><li>SingletonObject (一级, 日常获取Bean的地方)</li><li>earlySingletonObject (二级, 已实例化, 但是还没进行属性注入, 由三级缓存放进来)</li><li>singletonFactories(三级, Value是一个对象工厂 )</li></ul><blockquote><p>结合刚刚的过程</p></blockquote><ol><li><p>A对象实例化后, 属性注入之前, 其实会把A对象放入三级缓存中;</p><ul><li>key是BeanName, Value是ObjectFatory</li></ul></li><li><p>等到A对象属性注入时, 发现依赖B, 又要去实例化B时</p></li><li><p>B属性注入需要获取A, 这里就是从三级缓存中拿处ObjectFactory, 拿到对应的Bean (也就是对象A)</p></li><li><p>把三级缓存的A记录干掉, 再放到二级缓存中</p><ul><li>二级缓存存储的key是BeanName, Value就是Bean, 这里的Bean还没完成属性注入</li></ul></li><li><p>等到完成初始化后, 就会把二级缓存给remove掉, 然后放入一级缓存中, 我们自己去getBean的时候, 实际上拿到的就是以及缓存</p></li></ol><h2 id="_13-为什么需要三级缓存-不是二级缓存" tabindex="-1">13 为什么需要三级缓存 不是二级缓存 <a class="header-anchor" href="#_13-为什么需要三级缓存-不是二级缓存" aria-label="Permalink to &quot;13 为什么需要三级缓存 不是二级缓存&quot;">​</a></h2><p>只要两个缓存确实可以做到解决循环依赖的问题，但是有一个前提这个bean没被AOP进行切面代理，如果这个bean被AOP进行了切面代理，那么只使用两个缓存是无法解决问题，下面来看一下bean被AOP进行了切面代理的场景</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9d73decec7d4618b53c83f53d07cf82~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"> 我们发现AService的testAopProxy被AOP代理了，看看传入的匿名内部类的getEarlyBeanReference返回的是什么对象</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48460ca0afbb43eda7c42cf36ca6c774~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>发现singletonFactory.getObject()返回的是一个AService的代理对象，还是被CGLIB代理的。再看一张再执行一遍singletonFactory.getObject()返回的是否是同一个AService的代理对象</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75e9403a9b9a4129a105625c566d52be~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>我们会发现再执行一遍singleFactory.getObject()方法又是一个新的代理对象，这就会有问题了，因为AService是单例的，每次执行singleFactory.getObject()方法又会产生新的代理对象，假设这里只有一级和三级缓存的话，我每次从三级缓存中拿到singleFactory对象，执行getObject()方法又会产生新的代理对象，这是不行的，因为AService是单例的</p><p>所有这里我们要借助二级缓存来解决这个问题，将执行了singleFactory.getObject()产生的对象放到二级缓存中去，后面去二级缓存中拿，没必要再执行一遍singletonFactory.getObject()方法再产生一个新的代理对象，保证始终只有一个代理对象。还有一个注意的点</p><blockquote><p>既然singleFactory.getObject()返回的是代理对象，那么注入的也应该是代理对象，我们可以看到注入的确实是经过CGLIB代理的AService对象。<strong>所以如果没有AOP的话确实可以两级缓存就可以解决循环依赖的问题，如果加上AOP，两级缓存是无法解决的，不可能每次执行singleFactory.getObject()方法都给我产生一个新的代理对象，所以还要借助另外一个缓存来保存产生的代理对象</strong></p></blockquote></div></div></main><footer class="VPDocFooter" data-v-c4b0d3cf data-v-face870a><!--[--><!--]--><!----><!----></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"articles_周报小记.md\":\"ebd1bdc0\",\"index.md\":\"2c05d768\",\"guide_test.md\":\"287d2ae0\",\"java_java-jvm.md\":\"10ae9e47\",\"articles_3.15.md\":\"bd878997\",\"pattern_creational-pattern.md\":\"0ffd5ba2\",\"middleware_redis.md\":\"4fe63d8a\",\"java_java-mybatis.md\":\"b683b935\",\"articles_4.3-4.7小记.md\":\"0146b528\",\"guide_index.md\":\"edab4817\",\"java_java-spring.md\":\"c2c79922\",\"sql_mysql.md\":\"c3976556\",\"java_java-base.md\":\"741b321f\"}")
__VP_SITE_DATA__ = JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"VitePress\",\"description\":\"A VitePress site\",\"base\":\"/\",\"head\":[],\"appearance\":true,\"themeConfig\":{\"base\":\"/Junlogz-Blog\",\"siteTitle\":\"Junlogz-Docs\",\"logo\":\"/edit.png\",\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/Junlogz\"}],\"nav\":[{\"text\":\"Java\",\"items\":[{\"text\":\"Java基础\",\"link\":\"java/java-base\"},{\"text\":\"Jvm\",\"link\":\"java/java-jvm\"},{\"text\":\"Spring\",\"link\":\"java/java-spring\"},{\"text\":\"Mybatis\",\"link\":\"java/java-mybatis\"}]},{\"text\":\"设计模式\",\"items\":[{\"items\":[{\"text\":\"创建型模式\",\"link\":\"pattern/creational-pattern\"}]},{\"items\":[{\"text\":\"结构型模式\",\"link\":\"pattern/creational-pattern\"}]},{\"items\":[{\"text\":\"行为模式\",\"link\":\"pattern/creational-pattern\"}]}]},{\"text\":\"中间件\",\"items\":[{\"text\":\"redis\",\"link\":\"middleware/redis\"}]},{\"text\":\"数据库\",\"link\":\"sql/mysql\"},{\"text\":\"github\",\"link\":\"https://github.com/Junlogz\"}],\"sidebar\":{\"/articles/\":[{\"text\":\"日常小记\",\"collapsible\":true,\"collapsed\":true,\"items\":[{\"text\":\"4.3-4.7小记\",\"link\":\"/articles/4.3-4.7小记\"},{\"text\":\"3.15\",\"link\":\"/articles/3.15\"}]},{\"text\":\"周报\",\"collapsible\":true,\"collapsed\":true,\"items\":[{\"text\":\"周报小记\",\"link\":\"/articles/周报小记\"}]}]}},\"locales\":{},\"scrollOffset\":90,\"cleanUrls\":false}")</script>
    
  </body>
</html>